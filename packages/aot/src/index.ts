/**
 * Pre-compile native modules with automatic TypeScript declaration generation.
 * Supports watch mode, cross-compilation, and build caching.
 * @module
 */

import type {
    SourceLanguage,
    FFISymbolDef,
    AOTOptions,
    AOTResult,
    BuildConfig,
} from "@bunnativekit/types";
import { compile } from "@bunnativekit/compiler";
import { getCacheSubdir, hashFile, generateCacheKey } from "@bunnativekit/cache";
import { getCurrentArch, getCurrentPlatform, getPlatformInfo } from "@bunnativekit/platform";
import { getLogger } from "@bunnativekit/debug";
import { existsSync, mkdirSync, writeFileSync, readFileSync, watch } from "fs";
import { join, dirname, basename } from "path";

// types

export interface AOTCompileOptions extends AOTOptions {
    symbols?: Record<string, FFISymbolDef>;
    force?: boolean;
    verbose?: boolean;
}

// compiler

const logger = getLogger();

/** Compile native code ahead-of-time with TypeScript declarations */
export async function compileAOT(options: AOTCompileOptions): Promise<AOTResult> {
    const {
        source,
        output,
        generateTypes = true,
        watch: watchMode = false,
        symbols = {},
        force = false,
        verbose = false,
        build = {},
    } = options;

    // Ensure output directory exists
    if (!existsSync(output)) {
        mkdirSync(output, { recursive: true });
    }

    // Detect language
    const language = detectLanguage(source);

    // Generate cache key
    const sourceHash = await hashFile(source);
    const cacheKey = generateCacheKey(basename(source, getExtension(language)), sourceHash);

    const targetPlatform = build.platform ?? getCurrentPlatform();
    const targetArch = build.arch ?? getCurrentArch();

    // Check if rebuild needed
    const platformInfo = getPlatformInfo(targetPlatform);
    const libName = basename(source, getExtension(language));
    const libPath = join(output, `${platformInfo.libPrefix}${libName}${platformInfo.sharedExt}`);
    const typesPath = join(output, `${libName}.d.ts`);
    const metaPath = join(output, `${libName}.meta.json`);

    if (!force && existsSync(libPath) && existsSync(metaPath)) {
        // Check if source changed
        const meta = JSON.parse(readFileSync(metaPath, "utf-8"));
        const platformMatches = !meta.platform || meta.platform === targetPlatform;
        const archMatches = !meta.arch || meta.arch === targetArch;
        if (meta.sourceHash === sourceHash && platformMatches && archMatches) {
            logger.debug("aot", "Using cached build");
            return {
                success: true,
                outputs: {
                    library: libPath,
                    types: generateTypes ? typesPath : undefined,
                    meta: metaPath,
                },
            };
        }
    }

    // Compile
    const buildConfig: BuildConfig = {
        source,
        language,
        optimization: build.optimization ?? "speed",
        outName: libName,
        flags: build.flags,
        includes: build.includes,
        libs: build.libs,
        libPaths: build.libPaths,
        platform: build.platform,
        arch: build.arch,
    };

    const result = await compile(buildConfig, {
        sourceRoot: dirname(source),
        outputDir: output,
        platform: targetPlatform,
        arch: targetArch,
        verbose,
    });

    if (!result.success) {
        return {
            success: false,
            outputs: { library: "" },
            error: result.error,
        };
    }

    // Generate TypeScript declarations
    if (generateTypes && Object.keys(symbols).length > 0) {
        const types = generateTypeDeclarations(libName, symbols);
        writeFileSync(typesPath, types);
        logger.info("aot", `Generated types: ${typesPath}`);
    }

    // Write metadata
    const meta = {
        name: libName,
        sourceHash,
        compiledAt: Date.now(),
        platform: targetPlatform,
        arch: targetArch,
        symbols: Object.keys(symbols),
    };
    writeFileSync(metaPath, JSON.stringify(meta, null, 2));

    logger.info("aot", `Compiled: ${libPath}`);

    // Start watch mode if requested
    if (watchMode) {
        startWatcher(source, options);
    }

    return {
        success: true,
        outputs: {
            library: libPath,
            types: generateTypes ? typesPath : undefined,
            meta: metaPath,
        },
    };
}

// type generation

/** Generate TypeScript declarations from symbol definitions */
export function generateTypeDeclarations(
    moduleName: string,
    symbols: Record<string, FFISymbolDef>
): string {
    const lines: string[] = [
        `// Auto-generated by @bunnativekit/aot`,
        `// Do not edit manually`,
        ``,
        `declare module "${moduleName}" {`,
    ];

    for (const [name, def] of Object.entries(symbols)) {
        const args = def.args
            .map((type, i) => `arg${i}: ${ffiTypeToTS(type)}`)
            .join(", ");
        const returnType = ffiTypeToTS(def.returns);

        if (def.description) {
            lines.push(`  /** ${def.description} */`);
        }
        lines.push(`  export function ${name}(${args}): ${returnType};`);
    }

    lines.push(`}`);
    lines.push(``);
    lines.push(`export default {`);

    for (const name of Object.keys(symbols)) {
        lines.push(`  ${name},`);
    }

    lines.push(`};`);

    return lines.join("\n");
}

function ffiTypeToTS(type: string): string {
    switch (type) {
        case "void":
            return "void";
        case "bool":
            return "boolean";
        case "char":
        case "i8":
        case "i16":
        case "i32":
        case "u8":
        case "u16":
        case "u32":
        case "f32":
        case "f64":
            return "number";
        case "i64":
        case "u64":
        case "i64_fast":
        case "u64_fast":
            return "bigint";
        case "cstring":
            return "string";
        case "ptr":
        case "buffer":
            return "Pointer";
        case "function":
            return "Function";
        default:
            return "unknown";
    }
}

// watch mode

function startWatcher(source: string, options: AOTCompileOptions): void {
    logger.info("aot", `Watching for changes: ${source}`);

    const watcher = watch(source, async (eventType) => {
        if (eventType === "change") {
            logger.info("aot", "Source changed, recompiling...");
            await compileAOT({ ...options, watch: false, force: true });
        }
    });

    // Handle process exit
    process.on("SIGINT", () => {
        watcher.close();
        process.exit(0);
    });
}

// helpers

function detectLanguage(source: string): SourceLanguage {
    const ext = source.split(".").pop()?.toLowerCase();
    switch (ext) {
        case "zig":
            return "zig";
        case "c":
            return "c";
        case "cpp":
        case "cc":
        case "cxx":
            return "cpp";
        case "rs":
            return "rust";
        default:
            throw new Error(`Cannot detect language for: ${source}`);
    }
}

function getExtension(lang: SourceLanguage): string {
    switch (lang) {
        case "zig":
            return ".zig";
        case "c":
            return ".c";
        case "cpp":
            return ".cpp";
        case "rust":
            return ".rs";
    }
}

// exports

export const aot = {
    compile: compileAOT,
    generateTypes: generateTypeDeclarations,
};

export default aot;
